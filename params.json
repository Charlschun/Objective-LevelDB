{"name":"Objective-leveldb","tagline":"An Objective-C database library built over Google's LevelDB","body":"## Introduction\r\n\r\nAn Objective-C database library built over [Google's LevelDB](http://code.google.com/p/leveldb), a fast embedded key-value store written by Google.\r\n\r\n## Installation\r\n\r\nBy far, the easiest way to integrate this library in your project is by using [CocoaPods][1].\r\n\r\n1. Have [Cocoapods][1] installed, if you're not already\r\n2. In your Podfile, add the line \r\n\r\n        pod 'Objective-LevelDB'\r\n\r\n3. Run `pod install`\r\n4. Add the `libc++.dylib` Framework to your project.\r\n5. Make something awesome.\r\n\r\n## How to use\r\n\r\n### Creating/Opening a database file on disk\r\n\r\n```objective-c\r\nLevelDB *ldb = [LevelDB databaseInLibraryWithName:@\"test.ldb\"];\r\n```\r\n\r\n##### Setup Encoder/Decoder blocks\r\n\r\n```objective-c\r\nldb.encoder = ^ NSData * (LeveldBKey *key, id object) {\r\n  // return some data, given an object\r\n}\r\nldb.decoder = ^ id (LeveldBKey *key, NSData * data) {\r\n  // return an object, given some data\r\n}\r\n```\r\n\r\n#####  NSMutableDictionary-like API\r\n\r\n```objective-c\r\n[ldb setObject:@\"laval\" forKey:@\"string_test\"];\r\nNSLog(@\"String Value: %@\", [ldb objectForKey:@\"string_test\"]);\r\n\r\n[ldb setObject:@{@\"key1\" : @\"val1\", @\"key2\" : @\"val2\"} forKey:@\"dict_test\"];\r\nNSLog(@\"Dictionary Value: %@\", [ldb objectForKey:@\"dict_test\"]);\r\n```\r\nAll available methods can be found in its [header file](https://github.com/matehat/Objective-LevelDB/blob/master/Classes/LevelDB.h) (documented).\r\n\r\n##### Enumeration\r\n\r\n```objective-c\r\n[ldb enumerateKeysAndObjectsUsingBlock:^(LevelDBKey *key, id value, BOOL *stop) {\r\n    // This step is necessary since the key could be a string or raw data (use NSDataFromLevelDBKey in that case)\r\n    NSString *keyString = NSStringFromLevelDBKey(key); // Assumes UTF-8 encoding\r\n    // Do something clever\r\n}];\r\n\r\n// Enumerate with options\r\n[ldb enumerateKeysAndObjectsBackward:TRUE\r\n                              lazily:TRUE       // Block below will have a block(void) instead of id argument for value\r\n                       startingAtKey:someKey    // Start iteration there (NSString or NSData)\r\n                 filteredByPredicate:predicate  // Only iterate over values matching NSPredicate\r\n                           andPrefix:prefix     // Only iterate over keys prefixed with something \r\n                          usingBlock:^(LevelDBKey *key, void(^valueGetter)(void), BOOL *stop) {\r\n                             \r\n    NSString *keyString = NSStringFromLevelDBKey(key);\r\n    \r\n    // If we had wanted the value directly instead of a valueGetter block, we would've set the \r\n    // above 'lazily' argument to FALSE\r\n    id value = valueGetter();\r\n}]\r\n```\r\nMore iteration methods are available, just have a look at the [header section](https://github.com/matehat/Objective-LevelDB/blob/master/Classes/LevelDB.h)\r\n\r\n##### Snapshots, NSDictionary-like API (immutable)\r\n\r\nA snapshot is a readonly interface to the database, permanently reflecting the state of \r\nthe database when it was created, even if the database changes afterwards.\r\n\r\n```objective-c\r\nLDBSnapshot *snap = [ldb newSnapshot]; // You get ownership of this variable, so in non-ARC projects,\r\n                                       // you'll need to release/autorelease it eventually\r\n[ldb removeObjectForKey:@\"string_test\"];\r\n\r\n// The result of these calls will reflect the state of ldb when the snapshot was taken\r\nNSLog(@\"String Value: %@\", [snap objectForKey:@\"string_test\"]);\r\nNSLog(@\"Dictionary Value: %@\", [ldb objectForKey:@\"dict_test\"]);\r\n```\r\n\r\nAll available methods can be found in its [header file](https://github.com/matehat/Objective-LevelDB/blob/master/Classes/LDBSnapshot.h)\r\n\r\n##### Write batches, atomic sets of updates\r\n\r\nWrite batches are a mutable proxy to a `LevelDB` database, accumulating updates\r\nwithout applying them, until you do using `-[LDBWritebatch apply]`\r\n\r\n```objective-c\r\nLDBWritebatch *wb = [ldb newWritebatch];\r\n[wb setObject:@{ @\"foo\" : @\"bar\" } forKey: @\"another_test\"];\r\n[wb removeObjectForKey:@\"dict_test\"];\r\n\r\n// Those changes aren't yet applied to ldb\r\n// To apply them in batch, \r\n[wb apply];\r\n```\r\n\r\nAll available methods can be found in its [header file](https://github.com/matehat/Objective-LevelDB/blob/master/Classes/LDBWriteBatch.h)\r\n\r\n##### LevelDB options\r\n\r\n```objective-c\r\n// The following values are the default\r\nLevelDBOptions options = [LevelDB makeOptions];\r\noptions.createIfMissing = true;\r\noptions.errorIfExists   = false;\r\noptions.paranoidCheck   = false;\r\noptions.compression     = true;\r\noptions.filterPolicy    = 0;      // Size in bits per key, allocated for a bloom filter, used in testing presence of key\r\noptions.cacheSize       = 0;      // Size in bytes, allocated for a LRU cache used for speeding up lookups\r\n\r\n// Then, you can provide it when initializing a db instance.\r\nLevelDB *ldb = [LevelDB databaseInLibraryWithName:@\"test.ldb\" andOptions:options];\r\n```\r\n\r\n##### Per-request options\r\n\r\n```objective-c\r\ndb.safe = true; // Make sure to data was actually written to disk before returning from write operations.\r\n[ldb setObject:@\"laval\" forKey:@\"string_test\"];\r\n[ldb setObject:[NSDictionary dictionaryWithObjectsAndKeys:@\"val1\", @\"key1\", @\"val2\", @\"key2\", nil] forKey:@\"dict_test\"];\r\ndb.safe = false; // Switch back to default\r\n\r\ndb.useCache = false; // Do not use DB cache when reading data (default to true);\r\n```\r\n\r\n##### Concurrency\r\n\r\nAs [Google's documentation states][2], updates and reads from a leveldb instance do not require external synchronization\r\nto be thread-safe. Write batches do, and we've taken care of it, by isolating every `LDBWritebatch` it inside a serial dispatch \r\nqueue, and making every request dispatch *synchronously* to it. So use it from wherever you want, it'll just work.\r\n\r\nHowever, if you are using something like JSONKit for encoding data to JSON in the database, and you are clever enough to \r\npreallocate a `JSONDecoder` instance for all data decoding, beware that this particular object is *not* thread-safe, and you will\r\nneed to take care of it manually.\r\n\r\n### Testing\r\n\r\nIf you want to run the tests, you will need XCode 5, as the test suite uses the new XCTest. \r\n\r\nClone this repository and, once in it,\r\n\r\n```bash\r\n./setup-test.sh\r\ncd Tests && open Objective-LevelDB.xcworkspace\r\n```\r\n\r\nCurrently, all tests were setup to work with the iOS test suite.\r\n\r\n### License\r\n\r\nDistributed under the [MIT license](LICENSE)\r\n\r\n[1]: http://cocoapods.org\r\n[2]: http://leveldb.googlecode.com/svn/trunk/doc/index.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}